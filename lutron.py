"""
lutron.py

The Lutron module for porter, the Prometheus exporter.
Supports Homeworks QS, Homeworks Illumination Radio Ra2, Radio Ra2 Select,
Caseta PRO, and probably some others.

See https://github.com/upsert/liplib
and https://www.lutron.com/TechnicalDocumentLibrary/040249.pdf
"""

import asyncio, illiplib, json, liplib, logging, prometheus_client, time, threading
from prometheus_client.core import GaugeMetricFamily, CounterMetricFamily

LOGGER = logging.getLogger('porter.lutron')

REQUEST_TIME = prometheus_client.Summary('lutron_processing_seconds',
                                         'time of Lutron requests')

# for each target we have one "press_actions" counter with labels
# "area", "deviceid", "name", "button", and "scene_number", and one
# "output_level_pct" gauge with labels "area", "deviceid", "name".
#
# when the Lutron device tells us an output level has changed, we update the gauge.
# when the Lutron device tells us a press action has occurred, we increment the counter.
#
# a press action on deviceid 1 means that a scene was triggered, so we apply the
# scene_number label (area and button are empty). for other deviceids,
# scene_number is empty and button is the component that was pressed.


# Radio Ra2 Select supports the following parts of the Lutron Integration Protocol:
#   observe press and release of Pico buttons:
#      ~DEVICE,28,2,3
#      ~DEVICE,28,2,4
#         [various ~OUTPUT changes from the button action]
#   observe activation of scenes:
#      ~DEVICE,1,1,3
#         [various ~OUTPUT changes from the scene]
#      ~DEVICE,1,1,4
#   observe changes to output levels, e.g. from the app:
#      ~OUTPUT,23,1,0.00
#   query the output level of a dimmer:
#      ?output,26,1
#      returns ~OUTPUT,26,1,100.0
#   press and release a Pico button causing it to activate its associated outputs:
#      #device,28,2,3
#      #device,28,2,4
#   returns ~OUTPUT,26,1,100.00
#           ~OUTPUT,27,1,100.00
#           ~OUTPUT,23,1,100.00
#   run a scene
#      #device,1,2,3
#      #device,1,2,4

# LipServer supports all of that. We support all the monitoring above and also
# Homeworks QS monitoring of ~OUTPUT and ~SHADEGRP.

class ConfigParams:
    """
    We represent the configuration parameters for a single target. In production,
    we parse the config to read either the integration report or the YAML
    representation of the integration.

    We can also dump our state in YAML form, which is useful in order to
    convert the integration report into YAML form for easier understanding.
    """
    def __init__(self, toplutronconfig, target):
        self.lutronconfig = toplutronconfig.get(target) or toplutronconfig

        # we default to the username/password for Radio Ra2 Select
        if not self.lutronconfig.get('user'):
            self.lutronconfig['user'] = 'lutron'
        if not self.lutronconfig.get('password'):
            self.lutronconfig['password'] = 'integration'

        integration_json_string = self.lutronconfig.get('integration')
        if integration_json_string:
            self.process_integration_report(json.loads(integration_json_string))
        else:
            self._process_integration_yaml()

    def get(self, toplevel, default=None):
        return self.lutronconfig.get(toplevel, default)

    def process_integration_report(self, js):
        """Reads an integration report that was generated by the Lutron app for
        Radio Ra 2 Select. This overwrites any existing integration information from
        the config file or previous calls to this method.
        """
        lipidlist = js.get('LIPIdList')
        assert lipidlist, js

        self.sceneid_to_name = {} # all scenes are components of deviceid 1
        self.deviceid_to_sensortuple = {} # sensors (Pico or Occupancy Sensor)
        self.deviceid_to_dimmertuple = {}
        self.areaname_to_devices = {}
        def add_device(areaname, t):
            lis = self.areaname_to_devices.get(areaname)
            if not lis:
                lis = []
                self.areaname_to_devices[areaname] = lis
            lis.append(t)

        for device in lipidlist.get('Devices', []):
            if device['ID'] == 1: # then device is the Smart Bridge
                for button in device.get('Buttons', []):
                    name = button['Name']
                    if not name.startswith('Button '):
                        # then this "button" is a scene
                        self.sceneid_to_name[button['Number']] = name
            else: # then device is a sensor (Pico or occupancy sensor)
                areaname = device.get('Area', {}).get('Name', '')
                buttons = [b['Number'] for b in device.get('Buttons', [])]
                self.deviceid_to_sensortuple[device['ID']] = (device['Name'],
                                                              areaname, buttons)
                add_device(areaname, (device['ID'], device['Name'], buttons))

        for device in lipidlist.get('Zones', []):
            areaname = device.get('Area', {}).get('Name', '')
            self.deviceid_to_dimmertuple[device['ID']] = (device['Name'], areaname)
            add_device(areaname, (device['ID'], device['Name']))

    def _process_integration_yaml(self):
        """This processes the scenes and areas maps from the config to create the
        deviceid maps. Never needs to be called by the client because we do this
        automatically.
        """
        self.sceneid_to_name = self.lutronconfig.get('scenes', {})
        self.areaname_to_devices = self.lutronconfig.get('areas', {})
        self.deviceid_to_dimmertuple = {}
        self.deviceid_to_sensortuple = {}
        for (areaname, devicelist) in self.areaname_to_devices.items():
            for (deviceid, devicename, *buttons) in devicelist:
                if not buttons:
                    self.deviceid_to_dimmertuple[deviceid] = (devicename, areaname)
                else:
                    assert len(buttons) == 1, (deviceid, devicename, buttons)
                    self.deviceid_to_sensortuple[deviceid] = (devicename,
                                                              areaname, buttons[0])

    def dump_integration_yaml_string(self):
        """Returns a YAML format string that reflects the integration.
        It's more compact and easier to read than the integration JSON.
        """
        out = ['lutron:']
        out.append('  scenes:')
        for (sceneid, name) in sorted(self.sceneid_to_name.items()):
            out.append("    %d: '%s'" % (sceneid, name))
        out.append('  areas:')
        for (areaname, t) in sorted(self.areaname_to_devices.items()):
            lis = ['[%s]' % ', '.join([str(devid), "'%s'" % dname] + [str(b) for b in buttons]) for (devid, dname, *buttons) in t]
            out.append(("    '%s': [" % areaname) + ', '.join(lis) + ']')
        return '\n'.join(out)


class Lipservice:
    PING_TIME = 10*60 # number of seconds between keepalive pings
    QUERY_TIME = 60*60 # number of seconds between resynchronization poll

    # 80 is the magic number for seeTouch keypads;
    # other keypads have a different magic number (ugh)
    SEETOUCH_MAGIC = 80

    def __init__(self, host, port, cfparams, eventbus):
        self.host, self.port = host, port
        self.cfparams = cfparams
        self.eventbus = eventbus
        self.last_ping, self.last_query = time.time(), time.time()

        if self.cfparams.get('system', 'modern').lower() == 'illumination':
            self.lipserver = illiplib.IlluminationClient()
            self.device_ledquery = True
        else: # any modern Lutron system
            self.lipserver = liplib.LipServer()
            self.device_ledquery = False

        prompt = self.cfparams.get('prompt')
        if prompt:
            self.lipserver.prompt = prompt.encode() + b'> '
        
        self.counts_by_scene_number = {}
        self.counts_by_deviceid_component = {}
        self.outputlevels = {}
        for deviceid in self.cfparams.deviceid_to_dimmertuple.keys():
            self.outputlevels[deviceid] = None
        self.ledstates = {}
        for (deviceid, tup) in self.cfparams.deviceid_to_sensortuple.items():
            (name, area, buttons) = tup
            if len(buttons) > 1: # then it's a keypad, not an Illumination dimmer
                self.ledstates[deviceid] = {}
                for button in buttons:
                    self.ledstates[deviceid][button] = None
        # Hold the lock if you are going to add a key to the four dictionaries
        # above, or if you are going to iterate over those dictionaries outside
        # of the async task thread.
        self.cv = threading.Condition()

        LOGGER.info(f'new Lutron connection to {host}:{port}')

    async def open(self):
        await self.lipserver.open(self.host, self.port,
                                  username=self.cfparams.get('user').encode(),
                                  password=self.cfparams.get('password').encode())
        self.last_ping = time.time()

    async def open_and_query_levels(self):
        await self.open() # sets self.last_ping
        # no need to hold the lock because we are in the async task thread
        await self._query_levels()
        # if we are in the tasks_pending set we were put there by poll(),
        # so make sure we return to poll().
        return self.poll()

    async def _query_levels(self):
        self.last_query = time.time()
        self.last_ping = self.last_query
        for deviceid in self.outputlevels:
            # Action.SET in a query gets the current output level
            await self.lipserver.query('OUTPUT', deviceid, liplib.LipServer.Action.SET)
        for (deviceid, cmap) in self.ledstates.items():
            LEDSTATE = liplib.LipServer.Button.LEDSTATE
            if self.device_ledquery:
                await self.lipserver.query('DEVICE', deviceid, LEDSTATE)
            else:
                for button in cmap:
                    await self.lipserver.query('DEVICE', deviceid, button+self.SEETOUCH_MAGIC, LEDSTATE)

    async def query_levels_periodic(self):
        query_timeout = self.QUERY_TIME
        while self.last_query + query_timeout > time.time():
            await asyncio.sleep(self.last_query + query_timeout - time.time())
        await self._query_levels()
        return self.query_levels_periodic()

    async def ping(self):
        ping_timeout = self.PING_TIME
        while self.last_ping + ping_timeout > time.time():
            await asyncio.sleep(self.last_ping + ping_timeout - time.time())
        self.last_ping = time.time()
        await self.lipserver.ping()
        return self.ping()

    def _increment_counter(self, map_of_counters, key, increment=1):
        new_value = map_of_counters.get(key, 0) + increment
        with self.cv:
            map_of_counters[key] = new_value
        return new_value

    async def poll(self):
        """This method is misnamed. It doesn't poll, it blocks waiting
        for the Lutron device to emit a state change message."""
        (a, b, c, d) = await self.lipserver.read()
        if a is None:
            # then try to reconnect -- and since we may have missed
            # state updates while we were disconnected, we need to call
            # open_and_query_levels() to refresh our current state. happily,
            # open_and_query_levels() also reconnects us.
            #
            # remember that the way we have set up the wait() loop, when
            # a task in the wait() loop finishes, we create a new task
            # with the return value of the old task.
            return self.open_and_query_levels()
        elif a == 'DEVICE':
            if isinstance(d, tuple):
                deviceid, component, action, param = int(b), int(c), int(d[0]), float(d[1])
            else:
                deviceid, component, action = int(b), int(c), int(d)
            self.last_ping = time.time()
            if action == liplib.LipServer.Button.PRESS:
                if deviceid == 1: # then a scene was triggered
                    count = self._increment_counter(self.counts_by_scene_number, component)
                    self.eventbus.propagate((deviceid, 'scene', component))
                else: # a standalone device
                    count = self._increment_counter(self.counts_by_deviceid_component, (deviceid, component))
                    (name, area, buttons) = self.cfparams.deviceid_to_sensortuple.get(deviceid, ('', '', ''))
                    self.eventbus.propagate((deviceid, f'{area} {name}', component))
            elif action == liplib.LipServer.Button.LEDSTATE:
                if component > self.SEETOUCH_MAGIC and component < 20 + self.SEETOUCH_MAGIC:
                    component -= self.SEETOUCH_MAGIC
                cmap = self.ledstates.get(deviceid)
                if cmap is None:
                    cmap = {}
                    self.ledstates[deviceid] = cmap
                cmap[component] = int(param)
            # We ignore button releases even though that is where the action is taken.
            # Thus we also ignore double-press and long-press that can be reported
            # by Homeworks QS.
        elif a == 'OUTPUT' or a == 'SHADEGRP':
            # SHADEGRP is reported by Homeworks QS
            deviceid, action, level = b, c, d
            self.last_ping = time.time()
            if action == liplib.LipServer.Action.SET:
                self.outputlevels[deviceid] = level
            elif action == liplib.LipServer.Action.RAISING:
                # valid response, but outputlevel will be reported later so we ignore this
                pass
            elif action == liplib.LipServer.Action.LOWERING:
                # valid response, but outputlevel will be reported later so we ignore this
                pass
            elif action == liplib.LipServer.Action.STOP:
                pass
            elif a == 'SHADEGRP' and action == liplib.LipServer.Action.PRESET:
                pass # for Homeworks QS: activate the preset of a shade group
            elif action == 29 or action == 30:
                # These are reported by Homeworks QS and possibly others (though NOT
                # Radio Ra2 Select) and are not documented in the Homeworks Integration
                # Guide. I have no idea about action 30. For action 29:
                #    if value is 6, the previous change was caused by an integration command
                #       (i.e. something we might write)
                #    if value is 8, the change was caused by a keypad buttonpress
                #    if value is 10, it was caused by a motion sensor for "occupancy"
                #    if value is 11, it was caused by a motion sensor for "vacancy"
                pass
            else:
                LOGGER.warning(f'unknown ~OUTPUT action {action} for deviceid {deviceid} level {level} on  {self.host}:{self.port}')
        elif a == 'GROUP':
            # emitted by Homeworks QS to show occupancy status of an occupancy sensor group.
            # param of 3 means occupied, 4 means unoccupied, 255 is unknown
            deviceid, action, param = b, c, d
            self.last_ping = time.time()
            if action == 3:
                val = 100 if param == 3 else 0 if param == 4 else -1
                if val == -1:
                    LOGGER.warning(f'unknown GROUP param {param} for deviceid {deviceid} on  {self.host}:{self.port}')
                self.outputlevels[deviceid] = val
            else:
                LOGGER.warning(f'unknown GROUP action {action} {param} for deviceid {deviceid} on {self.host}:{self.port}')
        elif a == 'TIMECLOCK':
            deviceid, component, action = int(b), int(c), int(d)
            self.last_ping = time.time()
            if action == 1:
                pass # current timeclock mode
            elif action == 2:
                pass # sunrise
            elif action == 3:
                pass # sunset
            elif action == 5:
                pass # executing an indexed event
        elif a == 'KLS': # reported by Homeworks Illumination
            deviceid, ledstates = int(b), str(int(c))
            self.last_ping = time.time()
            leadingzeroes = 24 - len(ledstates)
            cmap = self.ledstates.get(deviceid)
            if cmap is None:
                cmap = {}
                self.ledstates[deviceid] = cmap
            for z in range(leadingzeroes):
                cmap[z+1] = 0
            for (count, val) in enumerate(ledstates):
                cmap[count+leadingzeroes+1] = int(val)
        elif a == 'SVS': # reported by Illumination but illiplib doesn't support
            self.last_ping = time.time()
        elif a == 'ERROR':
            LOGGER.error(f'~ERROR while polling {self.host}:{self.port}: {b} {c} {d}')
        else:
            LOGGER.warning(f'unknown response while polling {self.host}:{self.port}: {a} {b} {c} {d}')
        return self.poll() # return ourselves as coroutine so we are restarted

    async def run(self, deviceid, buttons, level, command, args):
        """Run command(args) on deviceid. Level is None or a percentage of full output."""
        LOGGER.info(f'{self.host}:{self.port} running {command}{args} on {deviceid}')
        if level is None and (command == 'minlevel' or command == 'maxlevel'):
            LOGGER.warning(f'unknown level for {deviceid} {command}{args}, assuming 0')
            level = 0
        if command == 'minlevel' and level > float(args[0]):
            return
        elif command == 'maxlevel' and level < float(args[0]):
            return
        if command == 'minlevel' or command == 'maxlevel' or command == 'setlevel':
            # args[0] is the output level (0-100); args[1] is optional fadetime
            SET = liplib.LipServer.Action.SET
            if self.cfparams.get('system', 'modern').lower() == 'illumination':
                args = (args[0], args[1] if len(args) > 1 else 0, 0)
                await self.lipserver.write('FADEDIM', deviceid, SET, *args)
            else:
                await self.lipserver.write('OUTPUT', deviceid, SET, *args)
        elif command == 'press':
            if self.cfparams.get('system', 'modern').lower() == 'illumination':
                mode = 'DBP' if len(buttons) == 1 else 'KBP'
                if args[0] not in buttons:
                    LOGGER.warning(f'{command}: {args[0]} not in {buttons}')
                LOGGER.debug(f'{command} {args[0]} executes as {mode} {deviceid} {args[0]}')
                await self.lipserver.write(mode, deviceid, args[0])
            else:
                if args[0] not in buttons:
                    LOGGER.warning(f'{command} {args[0]} not in {buttons}')
                component = args[0] + self.SEETOUCH_MAGIC
                PRESS = liplib.LipServer.Action.PRESS
                LOGGER.debug(f'{command} {args[0]} executes as DEVICE {deviceid} {component} {PRESS}')
                await self.lipserver.write('DEVICE', deviceid, component, PRESS)


class LipserviceManager:
    def __init__(self, eventbus):
        self.eventbus = eventbus
        self.cv = threading.Condition()
        self.target_to_cfparams = {}
        self.hostport_to_lipservice = {}
        self.tasks_pending = set()

    def register_target(self, lutronconfig, target):
        with self.cv:
            cfparams = self.target_to_cfparams.get(target)
            if not cfparams:
                cfparams = ConfigParams(lutronconfig, target)
                self.target_to_cfparams[target] = cfparams
            return cfparams

    def get_lipservice_for_target(self, target):
        (host, colon, portstr) = target.partition(':')
        port = int(portstr or 23)
        return self.hostport_to_lipservice.get((host, port))

    async def poll(self, timeout=1):
        with self.cv:
            targets = [t for t in self.target_to_cfparams.items()]
        for (target, cfparam) in targets:
            (host, colon, portstr) = target.partition(':')
            port = int(portstr or 23)
            lips = self.hostport_to_lipservice.get((host, port))
            if not lips:
                lips = Lipservice(host, port, cfparam, self.eventbus.target(target))
                self.hostport_to_lipservice[(host, port)] = lips
                # open_and_query_levels() will return poll() so that's what we'll do next
                self.tasks_pending.add(asyncio.create_task(lips.open_and_query_levels()))
                self.tasks_pending.add(asyncio.create_task(lips.query_levels_periodic()))
                self.tasks_pending.add(asyncio.create_task(lips.ping()))
        new_awaitables = set()
        self.eventbus.add_awaitables_to(new_awaitables)
        for awaitable in new_awaitables:
            if isinstance(awaitable, asyncio.Task):
                self.tasks_pending.add(awaitable)
            else:
                self.tasks_pending.add(asyncio.create_task(awaitable))

        if self.tasks_pending:
            (done, self.tasks_pending) = await asyncio.wait(
                self.tasks_pending, timeout=timeout, return_when=asyncio.FIRST_COMPLETED)
            for task in done:
                # as each poll() or ping() completes, schedule it to run again
                r = task.result()
                if r:
                    self.tasks_pending.add(asyncio.create_task(r))
        else:
            await asyncio.sleep(timeout)


class LutronClient:
    def __init__(self, config, eventbus):
        self.config = config
        self.manager = LipserviceManager(eventbus)
        lutronconfig = config.get('lutron')
        if not lutronconfig:
            raise Exception('no lutron configuration')
        self.clientstarttime = time.time()

    async def poll(self):
        await self.manager.poll()
        return self.poll()

    async def run(self, target, selector, command, *args):
        """For the first matching target, run command(args) on the device
        that matches selector.
        """
        cfparams = self.manager.register_target(self.config['lutron'], target)
        lips = self.manager.get_lipservice_for_target(target)
        if not lips:
            LOGGER.warning(f'lutron run() {target} ignored first time: {selector} {command}')
            return
        def is_selected(deviceid, name, area):
            return str(selector) == str(deviceid) or str(name).startswith(str(selector))
        with lips.cv:
            t = self._get_annotated_outputlevels_locked(lips, cfparams)
            for (deviceid, level, name, area, *buttons) in t:
                if is_selected(deviceid, name, area):
                    await lips.run(deviceid, buttons, level, command, args)
                    return
            for (deviceid, sensortuple) in cfparams.deviceid_to_sensortuple.items():
                (name, area, buttons) = sensortuple
                if is_selected(deviceid, name, area):
                    await lips.run(deviceid, buttons, None, command, args)
                    return
        LOGGER.warning(f'run() on {target} selected empty set {selector}')

    def _get_annotated_outputlevels_locked(self, lips, cfparams):
        """must hold lips.cv when you call this"""
        def annotate(deviceid):
            (name, area) = cfparams.deviceid_to_dimmertuple.get(deviceid, (None, ''))
            if name is None:
                # this can happen in Illumination, where dimmers are also sensors
                # (name, area, buttons)
                return cfparams.deviceid_to_sensortuple.get(deviceid, ('', '', []))
            else:
                return (name, area)
        return [(deviceid, level, *annotate(deviceid))
                for (deviceid, level) in lips.outputlevels.items()]

    @REQUEST_TIME.time()
    def collect(self, target):
        """request all the matching devices and get the status of each one"""

        cfparams = self.manager.register_target(self.config['lutron'], target)
        lips = self.manager.get_lipservice_for_target(target)
        if not lips:
            return []
        gmf = GaugeMetricFamily('output_level_pct',
                                'current output level (% of full output)',
                                labels=['deviceId', 'name', 'area'])
        gmfled = GaugeMetricFamily('led_state',
                                   'current state of keypad LED',
                                   labels=['deviceId', 'name', 'button', 'area'])
        cmf = CounterMetricFamily(
            'press_actions', 'count of button presses and scene activations',
            labels=['deviceId', 'name', 'button', 'area', 'scene_number'],
            created=self.clientstarttime
        )
        with lips.cv:
            t = self._get_annotated_outputlevels_locked(lips, cfparams)
            for (deviceid, level, name, area, *buttons) in t:
                if level is not None:
                    gmf.add_metric([str(deviceid), name, area], level)

            for (deviceid, cmap) in lips.ledstates.items():
                (name, area, buttons) = cfparams.deviceid_to_sensortuple.get(deviceid, ('', '', []))
                for component in buttons:
                    state = cmap.get(component)
                    if state is not None:
                        gmfled.add_metric([str(deviceid), name, str(component), area], state)

            for (sceneid, count) in lips.counts_by_scene_number.items():
                name = cfparams.sceneid_to_name.get(sceneid, '')
                cmf.add_metric(['', name, '', '', str(sceneid)], count)
            for (tup, count) in lips.counts_by_deviceid_component.items():
                (deviceid, component) = tup
                (name, area, buttons) = cfparams.deviceid_to_sensortuple.get(deviceid, (None, '', []))
                if name is None:
                    (name, area) = cfparams.deviceid_to_dimmertuple.get(deviceid, ('', ''))
                cmf.add_metric([str(deviceid), name, str(component), area], count)

        return [gmf, gmfled, cmf]

if __name__ == '__main__':
    import sys, yaml
    assert len(sys.argv) == 3, sys.argv
    config = yaml.safe_load(open(sys.argv[1]))
    client = LutronClient(config)
    cfparams = ConfigParams(config.get('lutron'), sys.argv[2])

    TESTING = False
    if TESTING:
        loop = asyncio.get_event_loop()
        loop.set_debug(True)
        coro = client.poll()
        while True:
            coro = loop.run_until_complete(coro)
            print(str(client.collect(sys.argv[2])))
        sys.exit(0)

    js = json.load(open(sys.argv[2], 'rt')) # the integration report from the bridge
    cfparams.process_integration_report(js)
    s = cfparams.dump_integration_yaml_string()
    print(s)

    #devices = liplib.load_integration_report(js)
    #print(json.dumps(devices, indent=2))
